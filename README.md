# Мини-приложение для введения учета заказов и остатков товара на полках магазинов.

## Описание
При помощи данного API можно вести учет товаров и заказов в каждом из магазинов.

---

### Что конкретно можно делать:
1. Получить список всех **товаров** в системе;
2. Получить список **остатков** на полках у магазинов;
3. Создать новый **товар** в системе;
4. Заполнить полки магазина **товаром**;
5. Создать **заказ**.

### Чуть подробнее о проекте
Сервис состоит из двух *микросервисов* - сервис ***Продукты*** и сервис ***История действий***. Они обе помещены в Docker-контейнеры, также для каждой из них развернуто по контейнеру с базой данных *Postgres*. 
Используется паттерн '*Api gateway*', в качестве входной точки для запросов служит Nginx (так же помещен в отдельный контейнер). Пока что он проксирует запросы от клиентов к сервису Продукты (при масштабировании сервиса и разработке новых микросервисов Nginx поможет перенаправлять запросы в любые другие нужные места).

### Структура проекта (код)
В корне находятся три папки - ./products (микросервис **товары**, написан на Express + TypeScript); ./history_service (микросервис **история действий**, Fastify + JavaScript), и ./nginx (**Шлюз АПИ**, запросы с клиента прокисрует по сервисам, в данном случае пока только на *Продукты*). Также в корне лежит **Docker-compose.yml** файл, по нему Docker собирает и запускает контейнеры.

### Требования:
Чтобы запустить приложение, на Вашем ПК должен быть установлены: Git, и запущен Docker.

### Как запустить сервис:
1. Склонировать этот проект себе:

``` git clone https://github.com/mant1ssa/shops_invertary ```

2. Запустить Docker на ПК
3. Открыть консоль в папке с проектом
4. Ввести команды друг за другом

``` docker compose build ```

```docker compose up ```

Приложение запустит 6 контейнеров:
- Контейнер сервиса **Товары**. Основная логика происходит именно там.
- Контейнер с **БД** для сервиса *Товары*. В папке ./products лежит предварительно заготовленный dump базы, где создаются таблицы:
-- *user* (пользователи системы. В логике пока не учавствуют, но для правдоподности проекта решил добавить)
-- *shop* (магазины)
-- *prodcut* (товары. Каждый товар соответсвует одному магазину (свзязь через shop_id), имеет поле PLU - артикул (вместо PK id можно было бы использовать и его, но решил для единобразия сделать id))
-- *shop_stock* (полки магазина. Находится информация о количестве товаров, находящихся на полке в магазине)
-- *order* (заказы. Информация о том, кто сделал заказ, что именно заказал (пока что в заказе учавствует только один вид товара), когда, и статус (пока логики для нее нет, но для правдоподобности оешил добавить))
-- *order_detail* (подробная информация о заказе (количество товара в заказе (связь через order_id)))
- Контейнер сервиса **История действий**. Тут происходит обработка действий клиентов (какое действие произошло, когда и сколько)
- Контейнер с **БД** для сервиса *История действий*.  В папке ./products лежит предварительно заготовленный dump базы, где создаются таблицы:
-- *history* (записи действиях, общаяя информация - дата и вид (создан товар, заказ или наполнена полка))
-- *history_detail* (подробная информация о действии - в каком магазине, какой продукт, сколько)
- Контейнер **rabbitMQ** (служит для того, чтобы передавать события из одного сервиса в другой (истории действий))
- Контейнер **Nginx** (проксирует запросы по контейнерам (пока что на *products*))
- 
## Куда делать запросы
Nginx проксирует запросы на сервис *Товары* на http://localhost/products
Для **получения всех товаров в системе** нужно сделать GET-запрос на http://localhost/products. Принимает в строке запроса параметры для фильтра, такие как PLU, name (строки), shopId (число), вот пример запроса: http://localhost/products?PLU=abcdefteqwe&shopId=3&name=ProductABC
Для **получения остатков** нужно сделать GET-запрос на http://localhost/products/stock. Принимает в строке запроса параметры для фильтра: PLU, name (строки), shopId (число), quantityInStock (массив из двух чисен, количество остатков на полке С-ПО), quantityInOrders (массив из двух чисел, количество остатков в заказе С-ПО). Пример запроса: http://localhost/products/stock?PLU=82734718918&quantityInStock=[1000,4000]&quantityInOrders=[2,10]&shopId=2dawda&name=Product1
Для **создания нового товара** нужно сделать POST-запрос на http://localhost/products. Ожидает тело вида:
```
{
    "PLU": "29729428321",
    "name": "Show",
    "shopId": 1
}
```
Для **добавления товара на полки** нужно сделать POST-запрос на http://localhost/products/stock. Ожидает тело вида:
```
{
    "shopId": 2,
    "productId": 2,
    "quantity": 50
}
```
Для **создания заказа** нужно сделать POST-запрос на http://localhost/products/order. Ожидает тело вида:
```
{
    "userId": 2,
    "productId": 1,
    "quantity": 10
}
```

## Небольшое послесловие
Данный проект нельзя назвать полностью завершенным, отлаженным, у него есть пару моментов, которые специально были упущены для ускорения разработки. При личном общении всех их можно будет обсудить. Вот пару моментов, которые хочу уточнить:
В коде есть достаточно моментов для обсуждения. Чтобы сильно не удлиннять разработку, оставил такие моменты, в личном разговоре можно осбудить все это подробнее
- По заданию есть такие ЭП, как создание остатка и увеличение (тут в проекте им выступает /products/stock, т.к. если у магазина еще нет этого товара на полках изначально, то мы создаем новый остаток, если же товар уже лежит на полках, то мы можем увеличить его остатки), а также уменьшение остатков (решил, что раз при заказе у нас полка чуть опустеет, то это и можно назвать уменьшением остатка товара на полке).
- С небольшой вероятностью может случиться такое, что RabbitMQ может запустить уже после инициализации сервисов, и в консоли будет выдана ошибка 'RabbitMQ не удалось запустить', происходит редко, но может случиться, тогда прошу заново пересобрать проект. В Docker-compose написал механизм, чтобы сервисы предварительно ожидали запуск сначала БД и транспортера, но если потратить чуть больше времени, то можно довести этот момент до идеала.
- Добавил бы самодокументацию (Swagger UI).
- Правильно будет добавить еще тесты для ручек (на работе используем Jest)
- В сервисе *Товары* чуть улучшил бы логику работы ошибок и ответов.
- Наполнить дамп более нормальными данными.
- Изменил бы инстанс подключения к БД.
- Напрашивается нормально применить Dependency Injection для уменьшения связанности модулей.
- Усовершенствовать валидацию входных данных.
- Код сервиса *История действий* нужно улучшить, т.к. на его разработку отвел чуть меньше времени чем на первый сервис.
- Может быть есть еще мелочи, которые мог упустить,хотел бы обсудить их уже на втором этапе)